In this program we solved the following list of problems

1. Reverse an Array
Reverses the elements of an array in-place using two pointers.

2. Rotate an Array by K
Rotates the array to the right (or left) by k steps. Can use reversal or temp array method.

3. Second Smallest Element
Finds the second minimum value in the array without sorting.

4. Second Largest Element
Finds the second maximum value in the array without sorting.

5. Third Largest Element
Retrieves the third highest element using a single traversal or sorting approach.

6. Third Smallest Element
Finds the third minimum element in the array with optimal comparisons.

7. Two Sum
Finds two indices in the array such that their values sum to a given target.

8. Move Zeroes to End
Moves all zeroes in the array to the end while maintaining the relative order of non-zero elements.

9. Next Greater Element
For each element in the array, finds the next greater element to its right using a stack.

10. Missing Number
Finds the missing number in an array containing numbers from 1 to N using the sum formula or XOR method.

11. Sort 0, 1, 2
Sorts an array consisting of only 0s, 1s, and 2s using the Dutch National Flag algorithm.

12. Sort Squared Array
Squares each element of a sorted array and returns a new sorted array of squares.

13. Find Minimum Array Sum
Calculates the minimum possible sum of array elements (based on problem variation â€” may include pair operations or reducing duplicates).

14. Triple Divisible
Finds and prints elements that are divisible by 3 in the given array. Could be extended to return triplets whose sum is divisible by 3.

15. Problem Statement:
There is an integer array nums sorted in ascending order (with distinct values).

Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].

Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

You must write an algorithm with O(log n) runtime complexity.

16. Problem Statement:
You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.

Increment the large integer by one and return the resulting array of digits.

17. Longest Consequence Subsequence

18. Maximum Subarray Sum
 
19. Remove duplicates from a array.

20. ThreeSum
